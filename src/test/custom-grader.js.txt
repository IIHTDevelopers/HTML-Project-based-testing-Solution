// const esprima = require('esprima');
// const fs = require('fs');
// const path = require('path');

// function gradeAssignment() {
//   // Path to the student's index.js file (located in /src)
//   const studentFilePath = path.join(__dirname, '..', 'index.js');  // Read from /src/index.js

//   // Read the student's JavaScript code from the index.js file
//   let studentCode;
//   try {
//     studentCode = fs.readFileSync(studentFilePath, 'utf-8');
//   } catch (err) {
//     console.error("Error reading student's file:", err);
//     return;
//   }

//   // Parse the student's code using Esprima
//   const ast = esprima.parseScript(studentCode);

//   // Initialize the result to 'Pass'
//   let result = 'Pass';
//   let feedback = [];

//   // 1. Check if 'name', 'age', 'isStudent' and 'greeting' are declared
//   let variablesDeclared = {
//     name: false,
//     age: false,
//     isStudent: false,
//     greeting: false
//   };

//   // 2. Check for the presence of the variables in the AST
//   ast.body.forEach((node) => {
//     if (node.type === 'VariableDeclaration') {
//       node.declarations.forEach((declarator) => {
//         if (declarator.id.name === 'name') variablesDeclared.name = true;
//         if (declarator.id.name === 'age') variablesDeclared.age = true;
//         if (declarator.id.name === 'isStudent') variablesDeclared.isStudent = true;
//         if (declarator.id.name === 'greeting') variablesDeclared.greeting = true;
//       });
//     }
//   });

//   // Check if all required variables are declared
//   for (let varName in variablesDeclared) {
//     if (!variablesDeclared[varName]) {
//       result = 'Fail';
//       feedback.push(`You must declare a variable called '${varName}'.`);
//     }
//   }

//   // 3. Check if 'greeting' variable is formed correctly
//   const greetingNode = ast.body.find((node) => node.type === 'VariableDeclaration' && node.declarations[0].id.name === 'greeting');
//   if (greetingNode) {
//     const greetingValue = greetingNode.declarations[0].init;
    
//     if (greetingValue.type !== 'TemplateLiteral' && (greetingValue.type !== 'BinaryExpression' || greetingValue.operator !== '+')) {
//       result = 'Fail';
//       feedback.push("The 'greeting' variable should combine 'name' and 'age' correctly using string concatenation or template literals.");
//     }
//   }

//   // 4. Check the variable types
//   ast.body.forEach((node) => {
//     if (node.type === 'VariableDeclaration') {
//       node.declarations.forEach((declarator) => {
//         const varName = declarator.id.name;
//         const initValue = declarator.init;

//         if (varName === 'name' && initValue.type !== 'Literal') {
//           result = 'Fail';
//           feedback.push("The 'name' variable should be assigned a string value.");
//         }

//         if (varName === 'age' && initValue.type !== 'Literal') {
//           result = 'Fail';
//           feedback.push("The 'age' variable should be assigned a numeric value.");
//         }

//         if (varName === 'isStudent' && initValue.type !== 'Literal') {
//           result = 'Fail';
//           feedback.push("The 'isStudent' variable should be assigned a boolean value.");
//         }
//       });
//     }
//   });

//   // Final feedback
//   if (result === 'Pass') {
//     feedback.push("Great job! Your code passed all the checks.");
//   } else {
//     feedback.push("Please correct the issues listed above.");
//   }

//   return { result, feedback };
// }

// // Run the grading function
// const { result, feedback } = gradeAssignment();
// console.log(result);  // Output: 'Pass' or 'Fail'
// console.log(feedback.join('\n'));  // Detailed feedback




const esprima = require('esprima');
const fs = require('fs');
const path = require('path');
const axios = require('axios');
const xmlBuilder = require('xmlbuilder');

// Define TestCaseResultDto
class TestCaseResultDto {
    constructor(methodName, methodType, actualScore, earnedScore, status, isMandatory, errorMessage) {
        this.methodName = methodName;
        this.methodType = methodType;
        this.actualScore = actualScore;
        this.earnedScore = earnedScore;
        this.status = status;
        this.isMandatory = isMandatory;
        this.errorMessage = errorMessage;
    }
}

// Define TestResults
class TestResults {
    constructor() {
        this.testCaseResults = {};
        this.customData = '';  // Include custom data from the file
    }
}

// Function to read the custom.ih file (similar to Angular code)
function readCustomFile() {
    let customData = '';
    try {
        customData = fs.readFileSync('../custom.ih', 'utf8');
    } catch (err) {
        console.error('Error reading custom.ih file:', err);
    }
    return customData;
}

// Function to send test case results to the server
async function sendResultsToServer(testResults) {
    try {
        const response = await axios.post('https://yaksha-prod-sbfn.azurewebsites.net/api/YakshaMFAEnqueue?code=jSTWTxtQ8kZgQ5FC0oLgoSgZG7UoU9Asnmxgp6hLLvYId/GW9ccoLw==', testResults, {
            headers: {
                'Content-Type': 'application/json'
            }
        });
        console.log('Server Response:', response.data);
    } catch (error) {
        console.error('Error sending data to server:', error);
    }
}

// Function to generate the XML report (similar to your original example)
function generateXmlReport(result) {
    const xml = xmlBuilder.create('test-cases')
        .ele('case')
        .ele('test-case-type', result.status)
        .up()
        .ele('name', result.methodName)
        .up()
        .ele('status', result.status)
        .up()
        .end({ pretty: true });
    return xml;
}

// Function to write to output files
function writeOutputFiles(result, fileType) {
    const outputFiles = {
        functional: "./output_revised.txt",
        boundary: "./output_boundary_revised.txt",
        exception: "./output_exception_revised.txt",
        xml: "./yaksha-test-cases.xml"
    };

    let resultStatus = result.status === 'Pass' ? 'PASS' : 'FAIL';
    let output = `${result.methodName}=${resultStatus}\n`;

    let outputFilePath = outputFiles[fileType];
    if (outputFilePath) {
        fs.appendFileSync(outputFilePath, output);
    }
}

// Function to grade the student's code
function gradeAssignment() {
    const studentFilePath = path.join(__dirname, '..', 'index.js');  // Read from /src/index.js
    let studentCode;

    try {
        studentCode = fs.readFileSync(studentFilePath, 'utf-8');
    } catch (err) {
        console.error("Error reading student's file:", err);
        return;
    }

    const ast = esprima.parseScript(studentCode);
    let result = 'Pass';
    let feedback = [];

    // Check if the variables are declared
    let variablesDeclared = { name: false, age: false, isStudent: false, greeting: false };
    ast.body.forEach((node) => {
        if (node.type === 'VariableDeclaration') {
            node.declarations.forEach((declarator) => {
                if (declarator.id.name === 'name') variablesDeclared.name = true;
                if (declarator.id.name === 'age') variablesDeclared.age = true;
                if (declarator.id.name === 'isStudent') variablesDeclared.isStudent = true;
                if (declarator.id.name === 'greeting') variablesDeclared.greeting = true;
            });
        }
    });

    for (let varName in variablesDeclared) {
        if (!variablesDeclared[varName]) {
            result = 'Fail';
            feedback.push(`You must declare a variable called '${varName}'.`);
        }
    }

    // Check if 'greeting' is correctly formed
    const greetingNode = ast.body.find((node) => node.type === 'VariableDeclaration' && node.declarations[0].id.name === 'greeting');
    if (greetingNode) {
        const greetingValue = greetingNode.declarations[0].init;
        if (greetingValue.type !== 'TemplateLiteral' && (greetingValue.type !== 'BinaryExpression' || greetingValue.operator !== '+')) {
            result = 'Fail';
            feedback.push("The 'greeting' variable should combine 'name' and 'age' correctly using string concatenation or template literals.");
        }
    }

    // Check variable types
    ast.body.forEach((node) => {
        if (node.type === 'VariableDeclaration') {
            node.declarations.forEach((declarator) => {
                const varName = declarator.id.name;
                const initValue = declarator.init;

                if (varName === 'name' && initValue.type !== 'Literal') {
                    result = 'Fail';
                    feedback.push("The 'name' variable should be assigned a string value.");
                }

                if (varName === 'age' && initValue.type !== 'Literal') {
                    result = 'Fail';
                    feedback.push("The 'age' variable should be assigned a numeric value.");
                }

                if (varName === 'isStudent' && initValue.type !== 'Literal') {
                    result = 'Fail';
                    feedback.push("The 'isStudent' variable should be assigned a boolean value.");
                }
            });
        }
    });

    // Read custom data from the custom.ih file
    const customData = readCustomFile();

    // Prepare the test result object
    const testCaseResult = new TestCaseResultDto(
        'VariableDeclarationAssignment',
        'boundary',
        1,
        result === 'Pass' ? 1 : 0,
        result,
        true,
        feedback.join(', ')
    );

    const testResults = new TestResults();
    const GUID = "d805050e-a0d8-49b0-afbd-46a486105170";  // Example GUID
    testResults.testCaseResults[GUID] = testCaseResult;
    testResults.customData = customData;

    console.log("Sending below data to server");
    console.log(testResults);

    // Send results to the server
    sendResultsToServer(testResults);

    // Generate XML report
    const xml = generateXmlReport(testCaseResult);
    fs.writeFileSync('./test-report.xml', xml);

    // Write to output files
    writeOutputFiles(testCaseResult, 'functional');
}

// Function to delete output files
function deleteOutputFiles() {
    const outputFiles = [
        "./output_revised.txt",
        "./output_boundary_revised.txt",
        "./output_exception_revised.txt",
        "./yaksha-test-cases.xml"
    ];

    outputFiles.forEach(file => {
        // Check if the file exists
        if (fs.existsSync(file)) {
            // Delete the file if it exists
            fs.unlinkSync(file);
            console.log(`Deleted: ${file}`);
        }
    });
}

// Function to delete output files and run the grading function
function executeGrader() {
    // Delete all output files first
    deleteOutputFiles();

    // Run the grading function
    gradeAssignment();
}

// Execute the custom grader function
executeGrader();